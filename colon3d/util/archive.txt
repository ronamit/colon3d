


    # --------------------------------------------------------------------------------------------------------------------

    def get_normalized_coords(self, points2d):
        """returns the corresponding normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))
        Args:
            points2d: 2D pixel locations in the (original) distorted image (shape: (N,2), units: pixels)
        Returns:
            undistorted: normalized 2D points in the undistorted image (shape: (N,2), units: normalized coordinates)
            is_valid: boolean array indicating if the point is valid (not outside the image)
        Notes:
            * Normalized coordinates correspond to the rectilinear camera with focal length is 1 and the optical center is at (0,0)
            The function first undistorts the fish-eye effect (if exists) and then transforms the coordinates to the normalized form:
            points2d_ext = np.hstack((points2d, np.ones((points2d.shape[0], 1))))
            nrm_coords = points2d_ext @ cam_K_mat_inv.T
        """
        n_points = points2d.shape[0]
        width = self.frame_width
        height = self.frame_height
        if self.is_fish_eye:
            x = np.round(points2d[:, 0]).astype(np.int32)
            y = np.round(points2d[:, 1]).astype(np.int32)
            # undistort the points
            undist_points = np.zeros((n_points, 2), dtype=np.float32)
            undist_points[:, 0] = self.undistort_map[0][y, x]
            undist_points[:, 1] = self.undistort_map[1][y, x]

            # sometimes the function cv2.fisheye.undistortPoints gives invalid values
            upper_lim = width + height  # some large number
            is_valid = np.sum(np.abs(undist_points), axis=1) < upper_lim
        else:
            # in case of rectilinear camera, the normalized coordinates are:
            points2d_ext = np.hstack((points2d, np.ones((n_points, 1))))
            nrm_coords = points2d_ext @ self.cam_K_mat_inv.T
            nrm_coords = nrm_coords[:, :2]
            is_valid = np.ones(n_points, dtype=bool)

        return nrm_coords, is_valid

    
    def compute_undistort_map(self):
        # in case of fish-eye camera, we first compute a mapping original (distorted) image to a undistorted (rectilinear) and rectified image.
        # the function computes the mapping and the camera matrix of the undistorted image
        # see:
        # * https://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#cv2.initUndistortRectifyMap
        # * https://stackoverflow.com/questions/39432322/what-does-the-getoptimalnewcameramatrix-do-in-opencv
        # * https://stackoverflow.com/questions/61147903/what-is-the-correct-way-to-undistort-points-captured-using-fisheye-camera-in-ope

        image_size = (self.frame_width, self.frame_height)
        W_in, H_in = image_size
        scale_factor = 1.0  # the scaling factor for the undistorted image size
        balance = 1.0  # the balance parameter for the undistorted image size centering
        img_dim_out = (int(W_in * scale_factor), int(H_in * scale_factor))
        K = self.cam_K_mat
        D = self.cam_distort_param
        if scale_factor != 1.0:
            K_out = K * scale_factor
            K_out[2, 2] = 1.0
        else:
            K_out = K.copy()
        K_new = cv2.fisheye.estimateNewCameraMatrixForUndistortRectify(
            K_out, D, img_dim_out, np.eye(3), balance=balance,
        )
        print("Newly estimated K:\n", K_new)
        # get the mapping from the original image to the undistorted and rectified image  (x,y) -> (map1(x,y), map2(x,y))
        self.undistort_map = cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(3), K_new, img_dim_out, cv2.CV_32F)

    # --------------------------------------------------------------------------------------------------------------------
    def get_undistorted_image(self, img: np.ndarray) -> np.ndarray:
        undistorted_img = cv2.remap(
            src=img,
            map1=self.undistort_map[0],
            map2=self.undistort_map[1],
            interpolation=cv2.INTER_LINEAR,
            borderMode=cv2.BORDER_CONSTANT,
        )
        return undistorted_img

    # --------------------------------------------------------------------------------------------------------------------

            # undistort the points
            # set accuracy criteria (to be used in fish-eye undistortion)
            criteria = (cv2.TERM_CRITERIA_COUNT | cv2.TERM_CRITERIA_EPS, 200, 1e-6)
            # change points2d to cv2 format
            points2d_cv2 = points2d[:, np.newaxis, :].astype(np.float32)
            nrm_coords = cv2.fisheye.undistortPoints(
                distorted=points2d_cv2,
                K=self.cam_K_mat,
                D=self.cam_distort_param,
                criteria=criteria,
            )
            # remove the extra dimension
            nrm_coords = np.squeeze(nrm_coords, axis=1)
            # sometimes the function cv2.fisheye.undistortPoints gives invalid values
            upper_lim = width + height  # some large number
            is_valid = np.sum(np.abs(nrm_coords), axis=1) < upper_lim









      # in case of a fisheye camera, we pre-calculated a lookup table for undistorting points
        self.undistort_mapping = cv2.initUndistortRectifyMap(
            cameraMatrix=self.cam_K_mat,
            distCoeffs=self.cam_distort_param,
            R=None,
            size=(self.frame_width, self.frame_height),
            m1type=cv2.CV_32FC1,
        )


import os
import pickle
from dataclasses import dataclass
from pathlib import Path

import cv2
import numpy as np
from matplotlib import pyplot as plt

from colon3d.utils.general_util import is_equal_dicts, save_plot_and_close


# --------------------------------------------------------------------------------------------------------------------
@dataclass
class CamInfo:
    """
    Metadata about the view
    """

    frame_width: int  # image width (unit: pixels)
    frame_height: int  # image height (units: pixels)
    cx: float  # optical center x position in the image (units: pixels)
    cy: float  # optical center y position in the image (units: pixels)
    fx: float  # focal length, normalized by the x-size of a pixel's sensor  (units: pixels)
    fy: float  # focal length, normalized by the y-size of a pixel's sensor  (units: pixels)
    distort_pram: np.ndarray  # Fisheye distortion parameters (cv2 format)
    fps: float | None  # frames per second (units: Hz)
    min_vis_z_mm: float  # the minimal z distance from the focal point that can be seen (units: mm)


# --------------------------------------------------------------------------------------------------------------------


class FishEyeUndistorter:
    """Class to undistort pixel coordinates in fisheye camera images to normalized oordinates in a rectilinear image.
    (target camera has zero distortion and a matrix K = unit matrix (fx = fy = 1, cx = cy = 0)
    """

    def __init__(self, cam_info: CamInfo, scene_path: Path):
        self.cam_K_mat = np.array([[cam_info.fx, 0, cam_info.cx], [0, cam_info.fy, cam_info.cy], [0, 0, 1]])
        self.cam_K_mat_inv = np.linalg.inv(self.cam_K_mat)
        self.cam_distort_param = cam_info.distort_pram
        self.frame_width = cam_info.frame_width
        self.frame_height = cam_info.frame_height
        self.fps = cam_info.fps
        self.is_fish_eye = self.cam_distort_param is not None and not np.allclose(self.cam_distort_param, 0)
        # in case of a fisheye camera, we pre-calculated a lookup table for undistorting points
        self.undistort_mapping = cv2.initUndistortRectifyMap(
            cameraMatrix=self.cam_K_mat,
            distCoeffs=self.cam_distort_param,
            R=None,
            size=(self.frame_width, self.frame_height),
            m1type=cv2.CV_32FC1,
        )

    # --------------------------------------------------------------------------------------------------------------------

    def get_undistort_points_lut(self, luts_folder_path: Path) -> np.ndarray:
        """
        get  a lookup table for undistorting points
        #  transforms normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))
        """

        undistort_config = {
            "frame_width": self.frame_width,
            "frame_height": self.frame_height,
            "cam_K_mat": self.cam_K_mat,
            "cam_distort_param": self.cam_distort_param,
        }
        if not luts_folder_path.exists():
            luts_folder_path.mkdir(parents=True)
        #  Try to load existing LUT
        lut_file_prefix = f"Undistort_LUT_{self.frame_width}X{self.frame_height}_"
        file_names = [
            fpath
            for fpath in os.listdir(luts_folder_path)
            if fpath.startswith(lut_file_prefix) and fpath.endswith(".npy")
        ]
        n_existing_files = len(file_names)
        i_file = 0
        found = False
        while not found and i_file < n_existing_files:
            file_name = f"{lut_file_prefix}{i_file}"
            # check that the LUT is for the same camera
            with (luts_folder_path / f"{file_name}.pkl").open("rb") as file:
                lut_config = pickle.load(file)
            if is_equal_dicts(lut_config, undistort_config):
                found = True
                lut = np.load(luts_folder_path / f"{file_name}.npy")
            else:
                i_file += 1
        if not found:
            # create a new LUT
            lut = create_undistortion_lut(undistort_config)
            # save the LUT and camera parameters
            np.save(luts_folder_path / f"{lut_file_prefix}{i_file}.npy", lut)
            with (luts_folder_path / f"{lut_file_prefix}{i_file}.pkl").open("wb") as file:
                pickle.dump(undistort_config, file)
            # save boolean image of not NaN values
            plt.figure()
            plt.imshow(~np.isnan(lut[:, :, 0]))
            plt.title("valid points")
            save_plot_and_close(luts_folder_path / f"{lut_file_prefix}{i_file}.png")
        return lut

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def get_normalized_coords(self, points2d):
        """returns the corresponding normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))
        Args:
            points2d: 2D points in the distorted image (shape: (N,2), units: pixels)
        Returns:
            undistorted: 2D points in the undistorted image (shape: (N,2), units: normalized coordinates)
            is_valid: boolean array indicating if the point is valid (not outside the image)
        """
        if self.is_fish_eye:
            # in case of a fisheye camera, we use the pre-calculated lookup table
            undistorted = self.undistort_points_lut[points2d[:, 1], points2d[:, 0]]
            is_valid = np.any(~np.isnan(undistorted), axis=-1)
        else:
            # in case of a rectilinear camera, we can just use the camera matrix
            cam_K_mat_inv = self.cam_K_mat_inv
            # add a third coordinate of 1 to the points
            points2d_ext = np.hstack((points2d, np.ones((points2d.shape[0], 1))))
            # transform to normalized coordinates
            undistorted = points2d_ext @ cam_K_mat_inv.T
            # normalize
            undistorted = undistorted[:, :2] / undistorted[:, 2:]
            is_valid = np.ones((points2d.shape[0],), dtype=bool)

        return undistorted, is_valid

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def get_normalized_coord(self, point2d):
        """returns the corresponding normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))
        Args:
            point2d: 2D point in the distorted image (shape: (2), units: pixels)
        Returns:
            undistorted: 2D points in the undistorted image (shape: (2))
        """
        assert isinstance(point2d, tuple)
        assert len(point2d) == 2
        return self.get_normalized_coords(np.array([point2d]))[0]

    # --------------------------------------------------------------------------------------------------------------------

    def project_from_cam_sys_to_pixels(self, points3d: np.ndarray):
        """
        Projects points in the 3D camera system to 2D pixels in the distorted image.
        Args:
            points3d: 3D points  in the camera system (shape: (N,3), units: mm)
        Returns:
            points2d: 2D points in the distorted image (shape: (2), units: pixels)
        """
        # set the translation & rotation to zero
        rot = np.array([[[0.0, 0.0, 0.0]]])
        trans = np.array([[[0.0, 0.0, 0.0]]])
        if points3d.ndim == 1:
            points3d = points3d[np.newaxis, :]
        points3d = points3d[:, np.newaxis, :]  # (N_points,1,3) to fit cv2.fisheye.projectPoints input
        # project points to image plane &  convert to pixels position in distorted image:
        points2d, _ = cv2.fisheye.projectPoints(points3d, rot, trans, self.cam_K_mat, self.cam_distort_param)
        points2d = np.squeeze(points2d, axis=1)  # (N,2)
        is_in_frame = (
            (points2d[:, 0] >= 0)
            & (points2d[:, 0] < self.frame_width)
            & (points2d[:, 1] >= 0)
            & (points2d[:, 1] < self.frame_height)
        )
        return points2d, is_in_frame


# --------------------------------------------------------------------------------------------------------------------


def create_undistortion_lut(undistort_config):
    """
        create  lookup table for undistorting points
    #  transforms pixel coordinates to  normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))

    """
    frame_width = undistort_config["frame_width"]
    frame_height = undistort_config["frame_height"]
    # create list of all points in the original image
    x = np.arange(frame_width)
    y = np.arange(frame_height)
    xv, yv = np.meshgrid(x, y, indexing="ij")
    points2d = np.stack([xv.flatten(), yv.flatten()], axis=1)
    # undistort the points
    undistorted, is_valid = run_undistort_points(undistort_config, points2d)
    lut = np.ones((frame_height, frame_width, 2), dtype=np.float32) * np.nan
    xv = xv.flatten()
    yv = yv.flatten()
    lut[yv[is_valid], xv[is_valid], 0] = undistorted[is_valid, 0]
    lut[yv[is_valid], xv[is_valid], 1] = undistorted[is_valid, 1]
    return lut


# --------------------------------------------------------------------------------------------------------------------


def run_undistort_points(undistort_config, points2d):
    """returns the corresponding normalized coordinates in the undistorted image  (transform to rectilinear camera with focal length is 1 and the optical center is at (0,0))
    Args:
        points2d: 2D points in the distorted image (shape: (N,2), units: pixels)
    Notes:
        * see https://stackoverflow.com/questions/61147903/what-is-the-correct-way-to-undistort-points-captured-using-fisheye-camera-in-ope
    """
    cam_K_mat = undistort_config["cam_K_mat"]
    cam_distort_param = undistort_config["cam_distort_param"]
    # img_size = (undistort_config["frame_width"], undistort_config["frame_height"])
    #  the desired K matrix is a unit matrix (fx = fy = 1 and cx = cy = 0)
    K_undistort = np.eye(3)
    points2d_in = points2d.copy()[:, np.newaxis, :].astype(float)

    # calculate the new camera matrix based on the free scaling parameter
    undistorted = cv2.fisheye.undistortPoints(
        distorted=points2d_in,
        K=cam_K_mat,
        D=cam_distort_param,
        R=None,
        P=K_undistort,
        criteria=(cv2.TERM_CRITERIA_COUNT | cv2.TERM_CRITERIA_EPS, 200, 1e-6),
    )
    undistorted = np.squeeze(undistorted, axis=1)
    # sometimes the function cv2.fisheye.undistortPoints gives invalid values
    upper_lim = 1e4
    is_valid = np.sum(np.abs(undistorted), axis=1) < upper_lim
    return undistorted, is_valid



      if self.is_fish_eye:
            image_size = (self.frame_width, self.frame_height)
            # in case of fish-eye camera, we need to undistort the image, and then transform to rectilinear camera
            new_camera_matrix, _ = cv2.getOptimalNewCameraMatrix(cameraMatrix=self.cam_K_mat, distCoeffs=self.cam_distort_param, imageSize=image_size, alpha=1, newImgSize=image_size)
            mapx, mapy = cv2.initUndistortRectifyMap(cameraMatrix=self.cam_K_mat, distortion_coeffs, None, new_camera_matrix, (w, h), cv2.CV_32F