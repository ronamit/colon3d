    

    
    
    
    # # # since we switched from LH to RH space, we need to flip the rotation angle sign.
    # cam_rot[:, 1:] *= -1

    # rotate the camera rotation by 90 degrees counter-clockwise around the z-axis (to align with the frame axes)
    # cam_rot = np_func(rotate_around)(in_quat=cam_rot, rot_axis=(0, 0, 1),  rot_angle=np.pi / 2)

# - -------------

# def quaternions_to_rotation_matrices(quaternions: np.ndarray) -> np.ndarray:
#     """
#     Converts unit-quaternions (real-fist format) to a 3x3 rotation matrices.
#     Args:
#         quaternion: [N x 4] unit-quaternions (real-fist format) representing rotations.
#     Returns:
#         rot_mats [N x 3 x 3] rotation matrices.
#     """
#     assert quaternions.shape[1] == 4
#     quaternions.shape[0]
#     # convert to scipy format:  (w, x, y, z) -> (x, y, z, w)
#     quant_real_last = quaternions[:, [1, 2, 3, 0]]
#     rot_mats = spr.from_quat(quant_real_last).as_matrix()
#     return rot_mats
# # ----------------------------------------------------------------------

# def rotation_matrices_to_quaternions(rot_mats: np.ndarray) -> np.ndarray:
#     """"
#     Converts rotation matrices to unit-quaternions (real-fist format).
#     Args:
#         rot_mats [N x 3 x 3] rotation matrices.
#     Returns:
#         quaternion: [N x 4] unit-quaternions (real-fist format) representing rotations.
#     """
#     assert rot_mats.shape[1:] == (3, 3)
#     # convert to scipy format:  (w, x, y, z) -> (x, y, z, w)
#     quant_real_last = spr.from_matrix(rot_mats).as_quat()
#     # convert to pytorch format: (x, y, z, w) -> (w, x, y, z)
#     quaternions = quant_real_last[:, [3, 0, 1, 2]]
#     return quaternions


# # ----------------------------------------------------------------------


# def translations_and_quaternions_to_matrices(translations: np.ndarray, quaternions: np.ndarray) -> np.ndarray:
#     """
#     Converts pairs of 3D translation vectors and rotations unit-quaternions to the corresponding 4x4 transformation matrices.

#     Args:
#         translations: [N x 3] the translation vectors.
#         quaternions: [N x 4] unit-quaternions (real-fist format) representing rotations.

   # # -------- debug prints  --------- #
    # if verbose:
    #     track_kps_inds = kp_weights_u == alg_prm.w_track_kp
    #     track_kps_nrm = kp_nrm_u[track_kps_inds]
    #     tracks_p3d_est = point3d_per_kp[track_kps_inds]
    #     track_projected_point_nrm = projected_point_nrm[track_kps_inds]
    #     if torch.numel(track_kps_nrm) > 0:
    #         print("-" * 100)
    #         # get the image coordinates of the track key-points
    #         n_track_kps = track_projected_point_nrm.shape[0]
    #         for i in range(n_track_kps):
    #              reprojected_est = orig_cam_undistorter.project_from_cam_sys_to_pixels(points3d=tracks_p3d_est[i])
    #             track_projected_point_nrm[i]
    #              =  
    #             print(f"Track KP (original fisheye frame): {track_kps_pix[i]}, Estimate re-projection: {track_projected_point_pix[i]}")
    #         print("-" * 100)


#     Returns:
#         transform_mats: [N x 4 x 4] the corresponding transformation matrices.
#     """

#     # Convert the quaternion to a rotation matrix.
#     rotation_matrix = quaternions_to_rotation_matrices(quaternions)

#     # Create the translation matrix.
#     transformation_matrix = np.eye(4)
#     transformation_matrix[:, :3, 3] = translations
#     transformation_matrix[:, :3, :3] = rotation_matrix

#     return transformation_matrix


# # ----------------------------------------------------------------------


# def invert_transformation_mat(transform_mat: np.ndarray) -> np.ndarray:
#     """"
#     Inverts a 4x4 transformation matrix.
#     """
#     rot_mat = transform_mat[:3, :3]
#     trans_vec = transform_mat[:3, 3]
#     inv_transform_mat = np.eye(4)
#     inv_transform_mat[:3, :3] = rot_mat.T
#     inv_transform_mat[:3, 3] = -rot_mat.T @ trans_vec
#     return inv_transform_mat


# # ---------------------------------------------------------------------------------------------------------------------
